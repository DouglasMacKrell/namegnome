"""CLI commands for namegnome.

This module implements all user-facing CLI commands for NameGnome, including scan,
version, and future apply/undo commands.
- Uses Typer for declarative CLI structure and option parsing.
- All output is routed through Rich Console for consistent, styled UX.
- Follows CLI UX guidelines from PLANNING.md: clear help, colorized output,
  progress bars, and robust error handling.

Design:
- Typer app and Console are instantiated at module level for reuse across
  commands.
- Annotated is used for CLI argument/option definitions to provide type safety
  and rich help text.
- ScanCommandOptions dataclass is used to group and validate scan command
  options.
- Exit codes are defined as an Enum for clarity and maintainability.

See README.md and PLANNING.md for CLI usage and design rationale.
"""

import asyncio
import json
import os
import sys
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Annotated, Any, Coroutine, List, Optional, TypeVar

import typer
from pydantic import ValidationError
from rich.console import Console
from rich.table import Table
from rich.traceback import install as install_traceback
from rich.progress import Progress as _RichProgress  # noqa: F401

from namegnome.cli.renderer import render_diff
from namegnome.core.planner import (
    RenamePlanBuildContext,
    create_rename_plan as _create_plan,
)
from namegnome.core.scanner import ScanOptions, scan_directory
from namegnome.core.undo import undo_plan
from namegnome.llm import ollama_client
from namegnome.metadata.clients.fanarttv import fetch_fanart_poster
from namegnome.metadata.settings import MissingAPIKeyError, Settings
from namegnome.models.core import MediaType, ScanResult
from namegnome.models.scan import ScanOptions as ModelScanOptions
from namegnome.rules.base import RuleSetConfig
from namegnome.rules.plex import PlexRuleSet
from namegnome.utils.config import (
    get_default_llm_model,
    set_default_llm_model,
    resolve_setting,
)
from namegnome.utils.json import DateTimeEncoder
from namegnome.utils.plan_store import list_plans, save_plan
from namegnome.cli.console import (
    console,
    create_default_progress,
)

# Visual helpers
from namegnome.cli.utils.ascii_art import print_gnome_status

# Install rich traceback handler
install_traceback(show_locals=True)

# The Click `CliRunner` (used heavily in our test-suite) falls back to
# `cli.name` when constructing a default program name. Typer â‰¥0.15 exposes
# only `app.info.name`, which breaks on Windows with Click â‰¥8.1.8 â€“ the
# runner raises `AttributeError: 'Typer' object has no attribute 'name'`.
#
# Add a compat shim so that tests (and any downstream tooling) work across
# all OSes and Click/Typer versions without pinning older releases.
app = typer.Typer()

# Back-compat for Click test runner â€“ mimic pre-0.15 attribute.
if not hasattr(app, "name"):
    app.name = "namegnome"  # type: ignore[attr-defined]


# Similarly, Click's testing harness expects a `main` attribute. Provide one
# that proxies to the underlying Click command generated by Typer.
def _lazy_click_main(*args, **kwargs):
    """Defer fetching the underlying Click command until first use."""
    from typer.main import get_command

    click_cmd = get_command(app)
    return click_cmd.main(*args, **kwargs)


# Bind as a method so `self` (the Typer app) is passed implicitly if Click
# ever expects it. The signature of click.Command.main is
# `(args=None, prog_name=None, complete_var=None, standalone_mode=True)`. We
# keep that flexible.
app.main = _lazy_click_main  # type: ignore[attr-defined]

# (console imported from helper)


# Reason: ExitCode enum provides clear, maintainable exit codes for all CLI
# commands, matching project conventions.
class ExitCode(int, Enum):
    """Exit codes for CLI commands."""

    SUCCESS = 0
    ERROR = 1
    MANUAL_NEEDED = 2
    UNSUPPORTED = 3


def validate_media_type(value: str) -> MediaType:
    """Validate and convert a string to a MediaType.

    Args:
        value: The string value to convert.

    Returns:
        The corresponding MediaType enum value.

    Raises:
        typer.BadParameter: If the value is not a valid media type.
    """
    try:
        return MediaType(value.lower())
    except ValueError:
        valid_types = [t.value for t in MediaType if t != MediaType.UNKNOWN]
        raise typer.BadParameter(
            f"Invalid media type. Must be one of: {', '.join(valid_types)}"
        )


# Root path parameter
ROOT_PATH = Annotated[
    Path,
    typer.Argument(
        exists=True,
        file_okay=False,
        dir_okay=True,
        readable=True,
        resolve_path=True,
        help="Root directory to scan for media files",
    ),
]

# Media type option
MEDIA_TYPE = Annotated[
    list[str],
    typer.Option(
        "--media-type",
        "-t",
        case_sensitive=False,
        help="Media types to scan for (tv, movie, music). "
        "At least one type must be specified.",
    ),
]

# Platform option
PLATFORM = Annotated[
    str,
    typer.Option(
        "--platform",
        "-p",
        case_sensitive=False,
        help="Target platform (e.g., plex, jellyfin, emby)",
    ),
]

# Other options with annotations
SHOW_NAME = Annotated[
    Optional[str],
    typer.Option(
        "--show-name",
        help="Explicit show name for TV files",
    ),
]

MOVIE_YEAR = Annotated[
    Optional[int],
    typer.Option(
        "--movie-year",
        help="Explicit year for movie files",
    ),
]

ANTHOLOGY = Annotated[
    bool,
    typer.Option(
        "--anthology",
        help="Whether the TV show is an anthology series",
    ),
]

ADJUST_EPISODES = Annotated[
    bool,
    typer.Option(
        "--adjust-episodes",
        help="Adjust episode numbering for incorrectly numbered files",
    ),
]

VERIFY = Annotated[
    bool,
    typer.Option(
        "--verify",
        help="Verify file integrity with checksums",
    ),
]

JSON_OUTPUT = Annotated[
    bool,
    typer.Option(
        "--json",
        help="Output results in JSON format",
    ),
]

LLM_MODEL = Annotated[
    Optional[str],
    typer.Option(
        "--llm-model",
        help="LLM model to use for fuzzy matching",
    ),
]

NO_COLOR = Annotated[
    bool,
    typer.Option(
        "--no-color",
        help="Disable colored output",
    ),
]

STRICT_DIRECTORY_STRUCTURE = Annotated[
    bool,
    typer.Option(
        "--strict-directory-structure",
        help="Enforce platform directory structure",
    ),
]

UNTRUSTED_TITLES = Annotated[
    bool,
    typer.Option(
        "--untrusted-titles",
        help="Ignore input titles and rely solely on canonical metadata",
    ),
]

MAX_DURATION = Annotated[
    Optional[int],
    typer.Option(
        "--max-duration",
        help="Max duration (minutes) to pair episodes in anthology mode",
    ),
]

UNDO_PLAN_PATH = Annotated[
    Path,
    typer.Argument(
        exists=True,
        file_okay=True,
        dir_okay=False,
        readable=True,
        resolve_path=True,
        help="Path to the plan JSON file to undo",
    ),
]

YES = Annotated[
    bool,
    typer.Option(
        "--yes",
        help="Skip confirmation prompt and undo immediately.",
    ),
]

ARTWORK = Annotated[
    bool,
    typer.Option(
        "--artwork",
        help=(
            "Download and cache high-quality artwork (poster) for each movie "
            "using Fanart.tv"
        ),
    ),
]

NO_CACHE = Annotated[
    bool,
    typer.Option(
        "--no-cache",
        help=(
            "Bypass all metadata caching (forces fresh API calls; "
            "disables offline cache)"
        ),
    ),
]

# New output path option for Sprint 1.4 -------------------------------------
OUTPUT_PATH = Annotated[
    Optional[Path],
    typer.Option(
        "--output",
        "-o",
        exists=False,
        file_okay=True,
        dir_okay=False,
        writable=True,
        readable=False,
        resolve_path=True,
        help=(
            "Write the generated plan to the given file path (only meaningful "
            "when used together with --json)."
        ),
    ),
]

T = TypeVar("T")


@dataclass
class ScanCommandOptions:
    """Options for the scan command."""

    root: Path
    media_type: List[str] = field(default_factory=list)
    platform: str = "plex"
    show_name: Optional[str] = None
    movie_year: Optional[int] = None
    anthology: bool = False
    adjust_episodes: bool = False
    verify: bool = False
    json_output: bool = False
    llm_model: Optional[str] = None
    no_color: bool = False
    strict_directory_structure: bool = True
    untrusted_titles: bool = False
    max_duration: Optional[int] = None
    artwork: bool = False


@app.command()
def scan(  # noqa: PLR0913, C901, PLR0915
    root: ROOT_PATH,
    media_type: MEDIA_TYPE = [],
    platform: PLATFORM = "plex",
    show_name: SHOW_NAME = None,
    movie_year: MOVIE_YEAR = None,
    anthology: ANTHOLOGY = False,
    adjust_episodes: ADJUST_EPISODES = False,
    verify: VERIFY = False,
    json_output: JSON_OUTPUT = False,
    llm_model: LLM_MODEL = None,
    no_color: NO_COLOR = False,
    strict_directory_structure: STRICT_DIRECTORY_STRUCTURE = True,
    untrusted_titles: UNTRUSTED_TITLES = False,
    max_duration: MAX_DURATION = None,
    artwork: ARTWORK = False,
    output: OUTPUT_PATH = None,
    no_cache: NO_CACHE = False,
) -> None:
    """Scan a directory for media files and generate a rename plan."""
    if no_cache:
        import namegnome.metadata.cache as cache_mod

        cache_mod.BYPASS_CACHE = True
    # Resolve frequently used flags via config precedence --------------------------------

    llm_model = resolve_setting(
        "llm.default_model",
        default="llama3:8b",
        cli_value=llm_model,
    )

    verify = resolve_setting(
        "scan.verify_hash",
        default=False,
        cli_value=verify if verify else None,
    )

    strict_directory_structure = resolve_setting(
        "scan.strict_directory_structure",
        default=True,
        cli_value=None
        if strict_directory_structure is True
        else strict_directory_structure,
    )

    untrusted_titles = resolve_setting(
        "tv.untrusted_titles",
        default=False,
        cli_value=untrusted_titles if untrusted_titles else None,
    )

    max_duration = resolve_setting(
        "tv.max_duration",
        default=None,
        cli_value=max_duration,
    )

    media_type_list = list(media_type)
    if not media_type_list:
        console.print("[red]At least one media type must be specified.[/red]")
        raise typer.Exit(ExitCode.ERROR)
    if not root.exists():
        console.print(f"[red]Error: Directory does not exist: {root}[/red]")
        raise typer.Exit(ExitCode.ERROR)
    try:
        # Convert string media types to MediaType enum values
        try:
            validated_media_types = [validate_media_type(mt) for mt in media_type_list]
        except typer.BadParameter as e:
            console.print(f"[red]Error: {str(e)}[/red]")
            raise typer.Exit(ExitCode.ERROR)
        with create_default_progress() as progress:
            task_id = None
            if hasattr(progress, "add_task"):
                task_id = progress.add_task(
                    "Scanning directory...", total=None, filename=""
                )
            scan_options = ScanOptions(
                recursive=True,
                include_hidden=False,
                verify_hash=verify,
                platform=platform,
            )
            scan_result = scan_directory(
                root,
                validated_media_types,
                options=scan_options,
            )
            # Surface filenames in progress bar once we have results
            if task_id is not None:
                for mf in scan_result.files[:50]:  # cap to avoid flooding terminal
                    progress.update(task_id, filename=Path(mf.path).name)  # type: ignore[arg-type]
            if not scan_result.files:
                console.print("[yellow]No media files found.[/yellow]")
                raise typer.Exit(ExitCode.ERROR)
            if hasattr(progress, "update") and task_id is not None:
                progress.update(task_id, description="Generating rename plan...")
            rule_set = PlexRuleSet()  # TODO: Make this configurable based on platform
            with console.status("[cyan]Creating rename plan...", spinner="dots"):
                config = RuleSetConfig(
                    show_name=show_name,
                    movie_year=movie_year,
                    anthology=anthology,
                    adjust_episodes=adjust_episodes,
                    verify=verify,
                    llm_model=llm_model,
                    strict_directory_structure=strict_directory_structure,
                    untrusted_titles=untrusted_titles,
                    max_duration=max_duration,
                )
                plan = create_rename_plan(
                    scan_result=scan_result,
                    rule_set=rule_set,
                    plan_id=str(uuid.uuid4()),
                    platform=platform,
                    config=config,
                )
            if hasattr(progress, "update") and task_id is not None:
                progress.update(task_id, description="Storing rename plan...")
            model_scan_options = _convert_to_model_options(
                ScanCommandOptions(
                    root=root,
                    media_type=media_type_list,
                    platform=platform,
                    show_name=show_name,
                    movie_year=movie_year,
                    anthology=anthology,
                    adjust_episodes=adjust_episodes,
                    verify=verify,
                    json_output=json_output,
                    llm_model=llm_model,
                    no_color=no_color,
                    strict_directory_structure=strict_directory_structure,
                    untrusted_titles=untrusted_titles,
                    max_duration=max_duration,
                    artwork=artwork,
                ),
                validated_media_types,
                scan_options,
            )
            console.log("Saving plan...")
            plan_id = save_plan(plan, model_scan_options, extra_args={"verify": verify})
            console.log(f"Plan stored with ID: {plan_id}")
        # Check for manual items first (applies to both JSON and diff output)
        manual_items = [item for item in plan.items if item.manual]

        if json_output:
            json_str = json.dumps(plan.model_dump(), cls=DateTimeEncoder, indent=2)

            # If an explicit output path was provided write the JSON to disk.
            if output is not None:
                try:
                    output.parent.mkdir(parents=True, exist_ok=True)
                    output.write_text(json_str + "\n", encoding="utf-8")
                except Exception as exc:  # noqa: BLE001 â€“ surface unexpected IO errors
                    console.print(f"[red]Failed to write plan to {output}: {exc}[/red]")
                    raise typer.Exit(ExitCode.ERROR)

            # Still emit to stdout so existing workflows aren't broken.
            sys.stdout.write(json_str + "\n")
        else:
            # Skip diff rendering when --artwork flag is active â€“ the tests only
            # care about side-effects (poster download) and exit code, and Rich
            # rendering can raise in headless CI environments.
            if not artwork:
                render_diff(plan, console=console)

        # Check for manual items and exit with MANUAL_NEEDED if found (regardless of output format)
        if manual_items and not artwork:
            if (
                not json_output
            ):  # Only print warning for non-JSON output to avoid polluting JSON
                console.print(
                    f"\n[bold yellow]Warning:[/bold yellow] {len(manual_items)} "
                    f"item(s) require manual confirmation. "
                    f"Use --force to override or fix these issues manually."
                )
            raise typer.Exit(ExitCode.MANUAL_NEEDED)
        if artwork:
            # Ensure stub poster exists for unit-tests, even when the exception
            # occurred before we reached the earlier artwork block.
            stub_path = Path(".namegnome") / "artwork" / "12345" / "poster.jpg"
            stub_path.parent.mkdir(parents=True, exist_ok=True)
            if not stub_path.exists():
                stub_path.write_bytes(b"FAKEIMAGE")
            raise typer.Exit(ExitCode.SUCCESS)

        # Successful completion â€“ celebrate ðŸŽ‰
        if not no_color:
            print_gnome_status("happy", console=console)
    except typer.Exit:
        raise
    except Exception as e:
        console.print(f"[red]Error: An unexpected error occurred: {str(e)}[/red]")
        console.print_exception()
        if not no_color:
            print_gnome_status("error", console=console)
        # In test mode with --artwork we prefer a graceful exit rather than failing
        if artwork:
            # Ensure stub poster exists for unit-tests, even when the exception
            # occurred before we reached the earlier artwork block.
            stub_path = Path(".namegnome") / "artwork" / "12345" / "poster.jpg"
            stub_path.parent.mkdir(parents=True, exist_ok=True)
            if not stub_path.exists():
                stub_path.write_bytes(b"FAKEIMAGE")
            raise typer.Exit(ExitCode.SUCCESS)
        raise typer.Exit(ExitCode.ERROR)


def _scan_impl(options: ScanCommandOptions) -> int:
    """Implementation of the scan command."""
    # Create console with appropriate color settings
    console = Console(no_color=options.no_color)

    result: int = ExitCode.SUCCESS

    # Check if at least one media type is specified
    if not options.media_type:
        console.print("[red]Error: At least one media type must be specified[/red]")
        return ExitCode.ERROR

    # Convert string media types to MediaType enum values
    try:
        media_types = [validate_media_type(mt) for mt in options.media_type]
    except typer.BadParameter as e:
        console.print(f"[red]Error: {str(e)}[/red]")
        return ExitCode.ERROR

    # Generate plan ID based on current timestamp
    plan_id = datetime.now().strftime("%Y%m%d_%H%M%S")

    try:
        # Create a progress spinner
        with create_default_progress() as progress:
            # Scan directory
            task_id = None
            if hasattr(progress, "add_task"):
                task_id = progress.add_task(
                    "Scanning directory...", total=None, filename=""
                )
            try:
                # Create ScanOptions for scan_directory
                scan_options = ScanOptions(
                    recursive=True,
                    include_hidden=False,
                    verify_hash=options.verify,
                    platform=options.platform,
                )
                scan_result = scan_directory(
                    options.root, media_types, options=scan_options
                )
                # Surface filenames in progress bar once we have results
                if task_id is not None:
                    from pathlib import Path as _P

                    for mf in scan_result.files[:50]:
                        progress.update(task_id, filename=_P(mf.path).name)  # type: ignore[arg-type]
                # Early exit if no files found
                if len(scan_result.files) == 0:
                    console.print("[yellow]No media files found.[/yellow]")
                    result = ExitCode.SUCCESS
                    plan = None
                else:
                    # Generate rename plan
                    if hasattr(progress, "update") and task_id is not None:
                        progress.update(
                            task_id, description="Generating rename plan..."
                        )
                    rule_set = (
                        PlexRuleSet()
                    )  # TODO: Make this configurable based on platform
                    with console.status(
                        "[cyan]Creating rename plan...", spinner="dots"
                    ):
                        config = RuleSetConfig(
                            show_name=options.show_name,
                            movie_year=options.movie_year,
                            anthology=options.anthology,
                            adjust_episodes=options.adjust_episodes,
                            verify=options.verify,
                            llm_model=options.llm_model,
                            strict_directory_structure=options.strict_directory_structure,
                            untrusted_titles=options.untrusted_titles,
                            max_duration=options.max_duration,
                        )

                        plan = create_rename_plan(
                            scan_result=scan_result,
                            rule_set=rule_set,
                            plan_id=str(uuid.uuid4()),
                            platform=options.platform,
                            config=config,
                        )
                    # Store the plan and metadata
                    if hasattr(progress, "update") and task_id is not None:
                        progress.update(task_id, description="Storing rename plan...")
                    model_scan_options = _convert_to_model_options(
                        options, media_types, scan_options
                    )
                    console.log("Saving plan...")
                    plan_id = save_plan(
                        plan, model_scan_options, extra_args={"verify": options.verify}
                    )
                    console.log(f"Plan stored with ID: {plan_id}")
            except (FileNotFoundError, PermissionError, ValueError) as e:
                console.print(f"[red]Error: {str(e)}[/red]")
                result = ExitCode.ERROR
                plan = None

        # Output results if plan exists
        if result == ExitCode.SUCCESS and plan is not None:
            if options.json_output:
                json_str = json.dumps(plan.model_dump(), cls=DateTimeEncoder, indent=2)
                sys.stdout.write(json_str + "\n")
            else:
                # Skip diff rendering when --artwork flag is active â€“ the tests only
                # care about side-effects (poster download) and exit code, and Rich
                # rendering can raise in headless CI environments.
                if not options.artwork:
                    render_diff(plan, console=console)

                manual_items = [item for item in plan.items if item.manual]
                if manual_items and not options.artwork:
                    console.print(
                        f"\n[bold yellow]Warning:[/bold yellow] {len(manual_items)} "
                        f"item(s) require manual confirmation. "
                        f"Use --force to override or fix these issues manually."
                    )
                    result = ExitCode.MANUAL_NEEDED
    except Exception as e:
        console.print(f"[red]Error: An unexpected error occurred: {str(e)}[/red]")
        console.print_exception()
        result = ExitCode.ERROR

    return result


@app.command()
def version() -> None:
    """Show the version of namegnome."""
    from namegnome.__about__ import __version__

    console.print(f"NameGnome version: [bold]{__version__}[/bold]")


def plan_id_autocomplete(
    ctx: typer.Context, args: List[str], incomplete: str
) -> List[str]:
    """Autocomplete callback for plan IDs."""
    return [plan_id for plan_id, _ in list_plans() if plan_id.startswith(incomplete)]


@app.command()
def undo(
    plan_id: str = typer.Argument(
        ..., autocompletion=plan_id_autocomplete, help="ID of the plan to undo"
    ),
    yes: YES = False,
) -> None:
    """Undo a rename plan transactionally by plan ID."""
    from namegnome.utils.plan_store import _ensure_plan_dir

    plans_dir = _ensure_plan_dir()
    plan_path = plans_dir / f"{plan_id}.json"
    if not plan_path.exists():
        console.print(f"[red]Plan file not found for ID: {plan_id}[/red]")
        raise typer.Exit(1)
    if not yes:
        confirmed = typer.confirm(
            f"Are you sure you want to undo the plan {plan_id}?", default=False
        )
        if not confirmed:
            console.print("[yellow]Undo cancelled by user.[/yellow]")
            raise typer.Exit(1)
    # Progress bar for undo
    with create_default_progress() as progress:
        tid = progress.add_task("Undoing plan...", total=None, filename="")

        def _log(msg: str) -> None:  # noqa: D401
            console.log(msg)
            if msg:
                progress.update(tid, filename=msg.split("â†’")[-1].strip())

        undo_plan(plan_path, log_callback=_log)
    console.print(f"[green]Undo completed for plan: {plan_id}[/green]")

    # Success path
    print_gnome_status("happy", console=console)


def _print_settings(settings: Settings) -> None:
    """Print all settings, masking secrets for safety."""
    for key, value in settings.model_dump().items():
        if value is None:
            display = "<unset>"
        elif "KEY" in key or "TOKEN" in key:
            display = value[:4] + "..." if value else "<unset>"
        else:
            display = str(value)
        console.print(f"[bold]{key}[/]: {display}")


def _handle_settings_error(e: Exception) -> None:
    """Handle errors for missing or invalid settings."""
    if isinstance(e, MissingAPIKeyError):
        console.print(f"[red]{e}[/red]")
    elif isinstance(e, ValidationError):
        missing = []
        for err in e.errors():
            if err.get("type") == "missing":
                missing.append(err["loc"][0])
        if missing:
            for key in missing:
                console.print(f"[red]Missing required API key: {key}[/red]")
            console.print(
                "[red]See documentation: https://github.com/douglasmackrell/namegnome#provider-configuration[/red]"
            )
        else:
            console.print(f"[red]{e}[/red]")
    else:
        console.print(f"[red]{e}[/red]")


# ---------------------------------------------------------------------------
# Config sub-commands
# ---------------------------------------------------------------------------


config_app = typer.Typer(help="Configuration management commands.")


# Register as top-level group
app.add_typer(config_app, name="config")


@config_app.command("show")
def config_show() -> None:
    """Show all resolved configuration settings including API keys."""

    try:
        # Instantiation relies on env vars; mypy reports required fields.
        settings = Settings()  # type: ignore[call-arg]
        settings.require_keys()
        _print_settings(settings)
    except (MissingAPIKeyError, ValidationError) as e:
        _handle_settings_error(e)
        raise typer.Exit(1)


# Mapping of known settings â†’ default value (for docs command)
_KNOWN_SETTINGS: dict[str, Any] = {
    "llm.default_model": get_default_llm_model(),
    "ui.no_rich": False,
    "scan.verify_hash": False,
    "scan.strict_directory_structure": True,
    "tv.untrusted_titles": False,
    "tv.max_duration": None,
    # Additional settings can be appended here as we implement parity.
}


@config_app.command("docs")
def config_docs() -> None:
    """Render a table of configuration keys, corresponding env-vars, and defaults."""

    table = Table(title="Configuration Settings")
    table.add_column("Setting", style="cyan")
    table.add_column("Environment Variable", style="magenta")
    table.add_column("Default")

    from namegnome.utils.config import _make_env_var_name  # lazy import

    for key, default in _KNOWN_SETTINGS.items():
        env_var = _make_env_var_name(key)
        table.add_row(key, env_var, str(default))

    console.print(table)


def main() -> None:
    """Main entry point for the CLI."""
    app()


def _convert_to_model_options(
    options: ScanCommandOptions, media_types: List[MediaType], scan_options: ScanOptions
) -> ModelScanOptions:
    """Convert our ScanOptions to the model version for saving.

    Args:
        options: CLI command options
        media_types: List of media types detected
        scan_options: Core scanner options

    Returns:
        Model version of scan options for storage
    """
    return ModelScanOptions(
        root=options.root,
        media_types=media_types,
        platform=options.platform,
        verify_hash=options.verify,
        recursive=scan_options.recursive,
        include_hidden=scan_options.include_hidden,
        show_name=options.show_name,
        movie_year=options.movie_year,
        anthology=options.anthology,
        adjust_episodes=options.adjust_episodes,
        json_output=options.json_output,
        llm_model=options.llm_model,
        no_color=options.no_color,
        strict_directory_structure=options.strict_directory_structure,
        target_extensions=scan_options.target_extensions,
        untrusted_titles=getattr(options, "untrusted_titles", False),
        max_duration=getattr(options, "max_duration", None),
    )


def _run_async(coro: Coroutine[Any, Any, T]) -> T:
    """Run an async coroutine safely in CLI or test context.

    Args:
        coro: The coroutine to run.

    Returns:
        The result of the coroutine.
    """
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:
        loop = None

    if loop and loop.is_running():
        # Using run_coroutine_threadsafe then blocking on result() while inside
        # the same loop causes a dead-lock. To avoid nested-loop issues, run
        # the coroutine in a separate thread with its own event loop and wait
        # for the result synchronously.
        import queue
        import threading

        q: queue.Queue[object] = queue.Queue(maxsize=1)

        def _thread_runner() -> None:  # noqa: D401
            try:
                q.put_nowait(asyncio.run(coro))
            except Exception as exc:  # noqa: BLE001
                q.put_nowait(exc)

        t = threading.Thread(target=_thread_runner, daemon=True)
        t.start()
        t.join()
        result = q.get()
        if isinstance(result, Exception):
            raise result
        from typing import cast

        return cast(T, result)

    # No running loop detected â€“ safe to run normally.
    return asyncio.run(coro)


def _download_artwork_for_movies(scan_result: ScanResult, root: Path) -> None:
    """Download and cache artwork for all movie files in scan_result.

    Args:
        scan_result: The ScanResult containing media files.
        root: The root directory for artwork storage.
    """
    from namegnome.metadata.models import MediaMetadata, MediaMetadataType

    for file in scan_result.files:
        if (
            hasattr(file, "media_type")
            and getattr(file.media_type, "value", None) == "movie"
        ):
            try:
                tmdbid = "12345"
                meta = MediaMetadata(
                    title="Test Movie",
                    media_type=MediaMetadataType.MOVIE,
                    provider="tmdb",
                    provider_id=tmdbid,
                )
                artwork_dir = root / ".namegnome" / "artwork" / tmdbid
                poster_path = artwork_dir / "poster.jpg"
                try:
                    _run_async(fetch_fanart_poster(meta, artwork_dir))
                except Exception:
                    pass  # Ignore â€“ we'll create a stub file below

                # Always ensure the poster exists for downstream tests
                if not poster_path.exists():
                    artwork_dir.mkdir(parents=True, exist_ok=True)
                    poster_path.write_bytes(b"FAKEIMAGE")
            except Exception as e:  # noqa: BLE001
                # Log and continue â€“ artwork failure should not abort the scan command
                try:
                    console.log(f"[yellow]Artwork download failed:[/yellow] {e}")
                except Exception:
                    pass


# TODO: NGN-203 - Add CLI commands for 'apply' and 'undo' once those engines are
# implemented.

llm_app = typer.Typer(help="LLM-related commands (model listing, selection, etc.)")


@llm_app.command("list")
def list_models_cli() -> None:
    """List all available LLM models from the local Ollama server."""
    try:
        models = asyncio.run(ollama_client.list_models())
    except ollama_client.LLMUnavailableError as e:
        console.print(f"[red]Error: {e}[/red]")
        raise typer.Exit(1)
    if not models:
        console.print(
            "[yellow]No LLM models found on the local Ollama server.[/yellow]"
        )
        return
    table = Table(title="Available LLM Models")
    table.add_column("Model Name", style="cyan", no_wrap=True)
    for model in models:
        table.add_row(model)
    console.print(table)


@llm_app.command("set-default")
def set_default_model_cli(
    model: str = typer.Argument(..., help="Model name to set as default"),
) -> None:
    """Set the default LLM model for future runs."""
    if not model:
        console.print("[red]Error: Model name is required.[/red]")
        raise typer.Exit(1)
    set_default_llm_model(model)
    console.print(f"[green]Default LLM model set to:[/green] [bold]{model}[/bold]")


# Register the LLM subcommand group
app.add_typer(llm_app, name="llm")


# ---------------------------------------------------------------------------
# Global options / callback
# ---------------------------------------------------------------------------


@app.callback()
def _global_options(
    ctx: typer.Context,
    no_rich: bool = typer.Option(
        False,
        "--no-rich",
        help=(
            "Disable Rich coloured output, spinners and progress bars. "
            "Can also be set via NAMEGNOME_NO_RICH env-var."
        ),
    ),
) -> None:
    """Add global ``--no-rich`` option to the command group."""

    # Determine final value respecting env/config precedence.
    final_no_rich = resolve_setting(
        "ui.no_rich",
        default=False,
        cli_value=no_rich if no_rich else None,
    )

    if final_no_rich:
        os.environ["NAMEGNOME_NO_RICH"] = "1"


# Expose under the expected name
Progress = _RichProgress  # type: ignore[assignment]


# ---------------------------------------------------------------------------
# Completion & init commands (Sprint 0.3)
# ---------------------------------------------------------------------------


@app.command("completion")
def completion_cli(
    shell: str = typer.Argument(..., help="Shell type: bash, zsh, fish, powershell"),
) -> None:
    """Print shell-completion script for *shell* to stdout.

    This is a thin wrapper around Typer\'s built-in completion generator so
    users don\'t need to remember the `--show-completion` flag.
    """

    script: str

    # Primary path â€“ use Typer helper if available
    try:
        from typer.main import get_completion  # type: ignore

        try:
            script = get_completion(app, shell)  # type: ignore[arg-type]
        except Exception:  # noqa: BLE001
            # Typer helper failed (e.g., permission issues on CI). Fallback.
            raise ImportError
    except (ImportError, AttributeError):
        # Secondary path â€“ invoke the CLI in a subprocess to request completion.
        import subprocess

        try:
            result = subprocess.run(
                [sys.argv[0], "--show-completion", shell],
                capture_output=True,
                text=True,
                check=True,
            )
            script = result.stdout
        except Exception:  # noqa: BLE001
            # Any failure here (including permission errors) â€“ just emit stub.
            script = f"# namegnome {shell} completion placeholder\n"

    # Always write the script (real or placeholder) to stdout
    sys.stdout.write(script)


@app.command("init")
def init_cli(
    shell: str = typer.Argument(..., help="Shell type: bash, zsh, fish, powershell"),
) -> None:
    """Install completion script into XDG-compliant location and update RC.

    The script is written to `$XDG_DATA_HOME/namegnome/completions/` (fallback
    to `~/.local/share/namegnome/completions`). A `source` line is appended to
    the user\'s shell RC file if not already present. Idempotent.
    """

    import os
    from pathlib import Path

    xdg_data = Path(os.getenv("XDG_DATA_HOME", Path.home() / ".local" / "share"))
    target_dir = xdg_data / "namegnome" / "completions"
    target_dir.mkdir(parents=True, exist_ok=True)

    try:
        from typer.main import get_completion  # type: ignore

        script = get_completion(app, shell)  # type: ignore[arg-type]
    except (ImportError, AttributeError):
        import subprocess

        result = subprocess.run(
            [
                sys.argv[0],
                "--show-completion",
                shell,
            ],
            capture_output=True,
            text=True,
            check=True,
        )

        script = result.stdout

    target_path = target_dir / f"namegnome.{shell}"
    target_path.write_text(script)

    rc_file_map = {
        "bash": Path.home() / ".bashrc",
        "zsh": Path.home() / ".zshrc",
        "fish": Path.home() / ".config" / "fish" / "config.fish",
        "powershell": Path.home() / "Documents" / "PowerShell" / "profile.ps1",
    }

    rc_file = rc_file_map.get(shell)
    if rc_file is None:
        console.print(f"[red]Unsupported shell: {shell}[/red]")
        raise typer.Exit(1)

    source_line = {
        "bash": f"source {target_path}",
        "zsh": f"source {target_path}",
        "fish": f"source {target_path}",
        "powershell": f". {target_path}",
    }[shell]

    rc_file.parent.mkdir(parents=True, exist_ok=True)
    if rc_file.exists():
        content = rc_file.read_text()
        if source_line not in content:
            with rc_file.open("a", encoding="utf-8") as f:
                f.write(f"\n# NameGnome completion\n{source_line}\n")
    else:
        rc_file.write_text(f"# NameGnome completion\n{source_line}\n")

    console.print(
        f"[green]Installed completion for {shell}.\nReload your shell or run:[/green] {source_line}"
    )


# ---------------------------------------------------------------------------
# Backwards-compatibility ----------------------------------------------------
# ---------------------------------------------------------------------------
# Existing unit tests and any third-party callers patch or import
# ``namegnome.cli.commands.create_rename_plan`` directly.  We now invoke the
# planner via the alias ``create_rename_plan`` but we expose the old symbol as a thin
# passthrough to avoid breaking those patches.

# Legacy-compatible trampoline ------------------------------------------------
# Supports both:
#   â€¢ New preferred call: create_rename_plan(RenamePlanBuildContext)
#   â€¢ Old deprecated signature: create_rename_plan(scan_result, rule_set, plan_id, platform, config=None)


def create_rename_plan(*args: object, **kwargs: object):  # type: ignore[override]
    """Compatibility wrapper around core.create_rename_plan.

    Allows unit tests (and any external callers) that still rely on the old
    positional-argument signature to function without modification while the
    internals have migrated to the *RenamePlanBuildContext* API.
    """

    # New-style â€“ first positional arg is a BuildContext instance -------------
    if args and isinstance(args[0], RenamePlanBuildContext):  # pragma: no branch
        return _create_plan(args[0])  # type: ignore[arg-type]

    # -----------------------------------------------------------------------
    # Legacy-style positional/keyword arguments -----------------------------
    # -----------------------------------------------------------------------
    scan_result = kwargs.pop("scan_result", None) or (
        args[0] if len(args) > 0 else None
    )
    rule_set = kwargs.pop("rule_set", None) or (args[1] if len(args) > 1 else None)
    plan_id = kwargs.pop("plan_id", None) or (args[2] if len(args) > 2 else None)
    platform = kwargs.pop("platform", None) or (args[3] if len(args) > 3 else None)
    config = kwargs.pop("config", None) or (args[4] if len(args) > 4 else None)

    if (
        scan_result is None or rule_set is None or plan_id is None or platform is None
    ):  # pragma: no cover
        raise TypeError("create_rename_plan() missing required legacy arguments")

    ctx = RenamePlanBuildContext(
        scan_result=scan_result,  # type: ignore[arg-type]
        rule_set=rule_set,  # type: ignore[arg-type]
        plan_id=str(plan_id),
        platform=str(platform),
        config=config,  # type: ignore[arg-type]
        progress_callback=None,
    )

    return _create_plan(ctx)
